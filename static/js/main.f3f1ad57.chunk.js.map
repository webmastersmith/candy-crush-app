{"version":3,"sources":["images/blank.png","images/blue-candy.png","images/green-candy.png","images/orange-candy.png","images/purple-candy.png","images/red-candy.png","images/yellow-candy.png","App.js","index.js"],"names":["App","useState","randomColorArray","setRandomColorArray","tileBeingDragged","setTileBeingDragged","tileBeingReplaced","setTileBeingReplaced","score","setScore","candyColors","useMemo","blueCandy","greenCandy","orangeCandy","purpleCandy","redCandy","yellowCandy","randomColor","candy","Math","floor","random","length","checkForColumnOfFour","useCallback","isMatch","idx","indexs","width","isColumnOfFour","every","index","isBlank","blank","forEach","s","checkForRowOfFour","notValid","includes","isRowOfFour","checkForColumnOfThree","isColumnOfThree","checkForRowOfThree","isRowOfThree","moveIntoSquareBelow","useEffect","colorArray","i","push","dragStart","e","target","dragDrop","preventDefault","dragEnd","tileDraggedId","parseInt","getAttribute","tileReplacedId","timer","setInterval","isMovedBlank","clearInterval","Wrapper","H1","Game","map","Tile","src","alt","onDragStart","draggable","onDragOver","onDragEnter","onDragLeave","onDrop","onDragEnd","Rules","styled","div","h1","img","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f3f1ad57.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/blank.fbcb9179.png\";","export default __webpack_public_path__ + \"static/media/blue-candy.73120c15.png\";","export default __webpack_public_path__ + \"static/media/green-candy.599f7016.png\";","export default __webpack_public_path__ + \"static/media/orange-candy.f106b2cd.png\";","export default __webpack_public_path__ + \"static/media/purple-candy.ae25b8a5.png\";","export default __webpack_public_path__ + \"static/media/red-candy.3658b37c.png\";","export default __webpack_public_path__ + \"static/media/yellow-candy.a3d87a9b.png\";","import { useState, useEffect, useMemo, useCallback } from 'react'\nimport styled from 'styled-components/macro'\nimport blank from './images/blank.png'\nimport blueCandy from './images/blue-candy.png'\nimport greenCandy from './images/green-candy.png'\nimport orangeCandy from './images/orange-candy.png'\nimport purpleCandy from './images/purple-candy.png'\nimport redCandy from './images/red-candy.png'\nimport yellowCandy from './images/yellow-candy.png'\n\nexport default function App() {\n  const [randomColorArray, setRandomColorArray] = useState([])\n  const [tileBeingDragged, setTileBeingDragged] = useState(null)\n  const [tileBeingReplaced, setTileBeingReplaced] = useState(null)\n  const [score, setScore] = useState(0)\n  const intervalDelay = 100\n\n  const candyColors = useMemo(\n    () => [\n      blueCandy,\n      greenCandy,\n      orangeCandy,\n      purpleCandy,\n      redCandy,\n      yellowCandy,\n    ],\n    []\n  )\n  const width = 8\n  const randomColor = (candy) => candy[Math.floor(Math.random() * candy.length)]\n\n  const checkForColumnOfFour = useCallback(() => {\n    let isMatch = false\n    for (let idx = 0; idx <= 39; idx++) {\n      const indexs = [idx, idx + width, idx + width * 2, idx + width * 3]\n      const isColumnOfFour = indexs.every(\n        (index) => randomColorArray[index] === randomColorArray[idx]\n      )\n      const isBlank = randomColorArray[idx] === blank\n      if (isColumnOfFour && !isBlank) {\n        // this changes randomColorArray, but does not cause DOM to update.\n        indexs.forEach((index) => (randomColorArray[index] = blank))\n        isMatch = true\n        setScore((s) => s + 4)\n      }\n    }\n    return isMatch\n  }, [randomColorArray])\n\n  const checkForRowOfFour = useCallback(() => {\n    let isMatch = false\n    const notValid = [\n      5, 6, 7, 13, 14, 15, 21, 22, 23, 29, 30, 31, 37, 38, 39, 45, 46, 47, 53,\n      54, 55, 61, 62, 63,\n    ]\n    for (let idx = 0; idx < randomColorArray.length; idx++) {\n      // board end pieces that cannot make four of a kind.\n      if (!notValid.includes(idx)) {\n        const indexs = [idx, idx + 1, idx + 2, idx + 3]\n        const isRowOfFour = indexs.every(\n          (index) => randomColorArray[index] === randomColorArray[idx]\n        )\n        const isBlank = randomColorArray[idx] === blank\n        if (isRowOfFour && !isBlank) {\n          // this changes randomColorArray, but does not cause DOM to update.\n          indexs.forEach((index) => (randomColorArray[index] = blank))\n          isMatch = true\n          setScore((s) => s + 4)\n        }\n      }\n    }\n    return isMatch\n  }, [randomColorArray])\n\n  const checkForColumnOfThree = useCallback(() => {\n    let isMatch = false\n    for (let idx = 0; idx <= 47; idx++) {\n      const indexs = [idx, idx + width, idx + width * 2]\n      const isColumnOfThree = indexs.every(\n        (index) => randomColorArray[index] === randomColorArray[idx]\n      )\n      const isBlank = randomColorArray[idx] === blank\n      if (isColumnOfThree && !isBlank) {\n        indexs.forEach((index) => (randomColorArray[index] = blank))\n        isMatch = true\n        setScore((s) => s + 3)\n      }\n    }\n    return isMatch\n  }, [randomColorArray])\n\n  const checkForRowOfThree = useCallback(() => {\n    let isMatch = false\n    const notValid = [\n      6, 7, 14, 15, 22, 23, 30, 31, 38, 39, 46, 47, 54, 55, 62, 63,\n    ]\n    for (let idx = 0; idx < randomColorArray.length; idx++) {\n      if (!notValid.includes(idx)) {\n        const indexs = [idx, idx + 1, idx + 2]\n        const isRowOfThree = indexs.every(\n          (index) => randomColorArray[index] === randomColorArray[idx]\n        )\n\n        const isBlank = randomColorArray[idx] === blank\n        if (isRowOfThree && !isBlank) {\n          indexs.forEach((index) => (randomColorArray[index] = blank))\n          isMatch = true\n          setScore((s) => s + 3)\n        }\n      }\n    }\n    return isMatch\n  }, [randomColorArray])\n\n  const moveIntoSquareBelow = useCallback(() => {\n    let isMatch = false\n    //loop through all but last row. Find blank ones and move to top row.\n    for (let idx = 0; idx <= 55; idx++) {\n      // if blank is in first row, add random candy\n      const firstRow = [0, 1, 2, 3, 4, 5, 6, 7]\n      const isFirstRow = firstRow.includes(idx)\n      // if blank has made it to the first row, insert random candy color.\n      if (isFirstRow && randomColorArray[idx] === blank) {\n        randomColorArray[idx] = randomColor(candyColors)\n        isMatch = true\n      }\n\n      //move all blanks up to top\n      if (randomColorArray[idx + width] === blank) {\n        isMatch = true\n        randomColorArray[idx + width] = randomColorArray[idx]\n        randomColorArray[idx] = blank\n      }\n    }\n    return isMatch\n  }, [randomColorArray, candyColors])\n\n  // run once on load. Create initial randomColorArray board and add to state.\n  useEffect(() => {\n    const colorArray = []\n    for (let i = 0; i < width * width; i++) {\n      colorArray.push(randomColor(candyColors))\n    }\n    setRandomColorArray(colorArray)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  const dragStart = (e) => setTileBeingDragged(e.target)\n  const dragDrop = (e) => {\n    e.preventDefault()\n    setTileBeingReplaced(e.target)\n  }\n  const dragEnd = (e) => {\n    // get 'data-id' from tile\n    const tileDraggedId = parseInt(tileBeingDragged.getAttribute('data-id'))\n    const tileReplacedId = parseInt(tileBeingReplaced.getAttribute('data-id'))\n\n    const validMoves = [\n      tileDraggedId - 1,\n      tileDraggedId + 1,\n      tileDraggedId - width,\n      tileDraggedId + width,\n    ]\n\n    // check if move is valid before checking if it created a match of 3 or 4.\n    const isValidMove = validMoves.includes(tileReplacedId)\n    if (isValidMove) {\n      //make candy switch, then check if it creates 3 or 4 match.\n      randomColorArray[tileReplacedId] = tileBeingDragged.getAttribute('src')\n      randomColorArray[tileDraggedId] = tileBeingReplaced.getAttribute('src')\n      const isColumnOfFour = checkForColumnOfFour()\n      const isRowOfFour = checkForRowOfFour()\n      const isColumnOfThree = checkForColumnOfThree()\n      const isRowOfThree = checkForRowOfThree()\n\n      // if any are true, do nothing, randomColorArray has already been switched.\n      if (isColumnOfFour || isRowOfFour || isColumnOfThree || isRowOfThree) {\n        // do nothing\n      } else {\n        // if not a match, return colors back to original.\n        randomColorArray[tileReplacedId] = tileBeingReplaced.getAttribute('src')\n        randomColorArray[tileDraggedId] = tileBeingDragged.getAttribute('src')\n      }\n    }\n  }\n\n  //run set interval and check board for matches\n  useEffect(() => {\n    const timer = setInterval(() => {\n      const isColumnOfFour = checkForColumnOfFour()\n      const isRowOfFour = checkForRowOfFour()\n      const isColumnOfThree = checkForColumnOfThree()\n      const isRowOfThree = checkForRowOfThree()\n      const isMovedBlank = moveIntoSquareBelow()\n      // check for changes and re-render view.\n      if (\n        isColumnOfFour ||\n        isRowOfFour ||\n        isColumnOfThree ||\n        isRowOfThree ||\n        isMovedBlank\n      ) {\n        // spread operator is needed to cause DOM re-render. Else view will not update.\n        setRandomColorArray([...randomColorArray])\n      }\n    }, intervalDelay)\n\n    return () => clearInterval(timer)\n  }, [\n    randomColorArray,\n    checkForColumnOfFour,\n    checkForRowOfFour,\n    checkForColumnOfThree,\n    checkForRowOfThree,\n    moveIntoSquareBelow,\n  ])\n\n  return (\n    <Wrapper>\n      <H1>Candy Crush</H1>\n      <H1>Score: {score}</H1>\n      <Game>\n        {randomColorArray.map((candy, idx) => (\n          <Tile\n            key={idx}\n            src={candy}\n            alt={idx}\n            data-id={idx}\n            onDragStart={dragStart}\n            draggable={true}\n            onDragOver={(e) => e.preventDefault()}\n            onDragEnter={(e) => e.preventDefault()}\n            onDragLeave={(e) => e.preventDefault()}\n            onDrop={dragDrop}\n            onDragEnd={dragEnd}\n          />\n        ))}\n      </Game>\n      <Rules>\n        Candy Crush Rules\n        <ul>\n          <li>You can only move one space at a time: up, down, left, right</li>\n          <li>\n            The moved tile must make three or four of a kind to be a valid move\n          </li>\n        </ul>\n      </Rules>\n    </Wrapper>\n  )\n}\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  padding: 30px;\n  align-items: center;\n`\nconst H1 = styled.h1`\n  font-size: 100%;\n  @media (min-width: 560px) {\n    font-size: 200%;\n  }\n  &:nth-child(2) {\n    margin-bottom: 1rem;\n  }\n  font-weight: bold;\n`\nconst Game = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  width: 320px;\n  height: 320px;\n  @media (min-width: 560px) {\n    width: 560px;\n    height: 560px;\n  }\n`\nconst Tile = styled.img`\n  width: 40px;\n  height: 40px;\n\n  @media (min-width: 560px) {\n    width: 70px;\n    height: 70px;\n  }\n`\nconst Rules = styled.div`\n  font-size: 75%;\n  @media (min-width: 560px) {\n    font-size: 100%;\n  }\n\n  margin-top: 4rem;\n  font-weight: bold;\n  text-align: center;\n  ul {\n    margin-top: 0;\n    li {\n      text-align: left;\n      font-weight: normal;\n    }\n  }\n`\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}